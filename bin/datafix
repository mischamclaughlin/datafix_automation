#!/usr/bin/env ruby

require 'yaml'
require 'optparse'
require 'json'
require 'fileutils'

$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))
require 'datafix'

options = {
  config: nil,
  input: nil,
  mapping: nil,
  output: nil,
  manual: nil,
  target_columns: nil,
  run_accounts: true,
  run_subscriptions: true,
  all: nil,
  old: nil
}

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: bin/datafix [options] [INPUT.xlsx MAPPING.yml]'

  opts.on('-c', '--config PATH', 'Path to config YAML') do |path|
    options[:config] = path
  end

  opts.on('-i', '--input PATH', 'Path to input XLSX file') do |path|
    options[:input] = path
  end

  opts.on('-m', '--mapping PATH', 'Path to mapping YAML file') do |path|
    options[:mapping] = path
  end

  opts.on('-o', '--output PATH', 'Path (and name) for output JSON file') do |path|
    options[:output] = path
  end

  opts.on('--manual', 'Enable manual column selection') do
    options[:manual] = true
  end

  opts.on('--no-manual', 'Disable manual column selection') do
    options[:manual] = false
  end

  opts.on('--target-columns', 'Use configured target columns') do
    options[:target_columns] = true
  end

  opts.on('--only TARGETS', 'Run subset: accounts, subs, both or all') do |targets|
    case targets.downcase
    when 'acc', 'accounts'
      options[:run_accounts] = true
      options[:run_subscriptions] = false
    when 'subs', 'subscriptions'
      options[:run_accounts] = false
      options[:run_subscriptions] = true
    when 'both'
      options[:run_accounts] = true
      options[:run_subscriptions] = true
    when 'all'
      options[:run_accounts] = false
      options[:run_subscriptions] = false
      options[:all] = true
    else
      abort "Unknown value for --only: #{targets} (expected accounts, subs, both, all)"
    end
  end

  opts.on('--old BOOLEAN', 'Output all data including old data') do |value|
    case value.downcase
    when 'on', 'true'
      options[:old] = true
    when 'off', 'false'
      options[:old] = false
    else
      abort "Unknown value for --old: #{value} (expected true or false)"
    end
  end

  opts.on('-v', '--version', 'Show version number') do
    puts "DataFix version #{DataFix::VERSION}"
    exit
  end

  opts.on('-h', '--help', 'Show help for CLI commands') do
    puts opts
    exit
  end
end

parser.parse!

config =
  if options[:config]
    path = File.expand_path(options[:config], Dir.pwd)
    File.exist?(path) ? (YAML.load_file(path) || {}) : {}
  else
    DataFix.config
  end

settings = config['settings'] || {}
settings = settings.merge('manual' => options[:manual]) unless options[:manual].nil?
settings = settings.merge('old_data' => options[:old]) unless options[:old].nil?
settings = settings.merge('target_columns' => options[:target_columns]) unless options[:target_columns].nil?
config = config.merge('settings' => settings)

files = config['files'] || {}

input_path = options[:input] || ARGV[0] || files['input_file']
php_admin_path = options[:mapping] || ARGV[1] || files['php_admin_file']

unless input_path && php_admin_path
  abort "#{parser}\n\n" \
        "Either provide INPUT.xlsx and MAPPING.yml as arguments,\n" \
        "use --input/--mapping options, or set 'input_file' and 'php_admin_file' in a config YAML."
end

input = DataFix::ParseFiles.new(input_file: input_path, config: config).parse_files(input_path)
php_admin_data = DataFix::ParseFiles.new(input_file: php_admin_path, config: config).parse_files(php_admin_path)

builder = DataFix::BuildData.new(parsed_data: input, parsed_php_admin_data: php_admin_data, config: config)

results = {}
results[:accounts] = builder.build_account_data if options[:run_accounts]
results[:subscriptions] = builder.build_subscription_data if options[:run_subscriptions]
results[:all_data] = builder.build_all_data('all') if options[:all]

json_output = JSON.pretty_generate(results)

base_output_path =
  if options[:output]
    options[:output]
  elsif files['output_file'] && !files['output_file'].empty?
    files['output_file']
  else
    input_basename = File.basename(input_path, File.extname(input_path)).downcase.gsub(/\s+/, '_')
    File.join('data/output', "#{input_basename}_datafix.json")
  end

full_output_path = File.expand_path(base_output_path, Dir.pwd)
FileUtils.mkdir_p(File.dirname(full_output_path))
File.write(full_output_path, json_output)

puts json_output
